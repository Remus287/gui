# Communication between Teensy and MOTE board

## SETUP INSTRUNCTIONS
1. Connect each MoTE board used to 12V power, connecting to the 2 pins on J1 closest to the top of the board. Upper pin is power, lower pin is ground. Connect each teensy to the router via ethernet, and connect the control console to the same router
2. In the file "Example SD card Root/sensor_min_test.csv", add all necessary sensors and/or actuators, make sure to specify mote number, pin number, and sensor type (see below for sensor types). For ADCs, the pin number is weird. The first digit is the ADC number (counting from the left, starting at 0), and the second digit is the pin number. E.g. ADC pin number 11 is J20, pin 1. For 2ch ADCs, use a pin number of 0 for the left two pins and pin number 1 for the right two pins.
3. Once the teensy is powered and conneted, run gui.py, the orange status light on the teensy will be on if there is a connection. If you need to change any config informaiton, REBOOT THE TEENSY!!

## Sensor Types
* Teensy ADC
* i2c ADC 1ch
* i2c ADC 2ch
* servoPWM
* servoPWM_12V
* Binary GPIO

## Identifying each Teensy and MOTE Board

Each MOTE board will hold a teensy. We can identify each by their unique MOTE number.

They will be last digit of each MOTE's static IP. That digit will be saved as an ascii-value in MoteNumber.txt in SD card.

## Communication Protocol

Protocol used between Teensy and the GUI will be done in **UDP**.

## Types of Functions

There are 4 types of read functions for sensors and 2 types of write functions for actuators.

Each function is assigned an Interface Type Number.

**Read functions:**

1. Teensy ADC
2. i2c ADC 1 channel (ads122c4)
3. i2c ADC 2 channel (ads122c4) (for thermocouple)
4. flowmeter counter

**Write functions:**

5. servo PWM
6. binary gpio

| Operation | Interface Type Number | Sensor/Actuator                                 |
| --------- | --------------------- | ----------------------------------------------- |
| READ      | 1                     | Teensy ADC                                      |
| READ      | 2                     | I2C ADC 1 channel (ads122c4)                    |
| READ      | 3                     | I2C ADC 2 channel (ads122c4) (for thermocouple) |
| READ      | 4                     | Flowmeter Counter                               |
| WRITE     | 5                     | Servo PWM                                       |
| WRITE     | 6                     | Binary GPIO                                     |

## Packet Data Structure

Each packet will be sent and received as a **byte array**.

### Sensor Config Commands (Server -> Teensy):

**Byte Array**

| Byte 1  | Byte 2      |
| ------- | ----------- |
| pin_num | config_byte |

**Bit Array of `config_byte`**

| Bit 1 (MSB)                                                              | Bit 2                                              | Bit 3 - 8             |
| ------------------------------------------------------------------------ | -------------------------------------------------- | --------------------- |
| actuator write command = 0 (since this is not an actuator write command) | actuator state (not used in sensor config packets) | Interface Type Number |

**NB 1.** Byte variable can be of type `char` or `uint8` or `hex` as its eight bits long.

**NB 2.** Given we are dealing with sensors, _Interface Type Number_ is either 1, 2, or 3, and _Bit 1_ and _Bit 2_ are 0.

**NB 3.** Knowing the pin number and sensor type is enough info to call the correct sensor read function, which takes pin number as argument.

### Actuator Write Commands (Server -> Teensy):

**Byte Array**

| Byte 1  | Byte 2      |
| ------- | ----------- |
| pin_num | config_byte |

**Bit Array of `config_byte`**

| Bit 1 (MSB)                                                            | Bit 2          | Bit 3 - 8             |
| ---------------------------------------------------------------------- | -------------- | --------------------- |
| Actuator write command = 1 (because this is an actuator write command) | actuator state | Interface Type Number |

**NB 4.** Given we are dealing with actuators, _Interface Type Number_ is either 4 or 5.

### Sensor Data (Teensy -> Server)

The byte array ar however many sensors there are in each teensy, whose information is provided in config file

Each Teensy will send to the server a differently lengthed byte array.

**Byte Array**

| Byte 1              | Byte 2-5               | Byte 6              | Byte 7-10              | etc. (5 bytes per sensor: 1 pin byte, 4 data bytes) |
| ------------------- | ---------------------- | ------------------- | ---------------------- | --------------------------------------------------- |
| pin_num of sensor_1 | data_value of sensor_1 | pin_num of sensor_2 | data_value of sensor_2 | Pin & dava_val of sensors_3-to-n                    |

**NB 5.** _data_value_ for each sensor is an int (4 bytes).

# To compile Teensy code from command line (without Arduino IDE). NOT USED FOR CURRENT CODE

If cloning this repo to compile firmware, you need to run the following once (to download the teensy4 core):

```
git submodule init
git submodule update
```

To update submodules:

```
git submodule foreach git pull

dependencies:
arm-none-eabi-newlib
arm-none-eabi-gcc
```

The PWMServo library is modified to INVERT the PWM duty cycle because we're using a MOSFET to drive a higher voltage, which inverts the signal
line 198 of PMWServo.cpp
